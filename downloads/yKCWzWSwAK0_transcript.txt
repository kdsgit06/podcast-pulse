Hi everyone. Thanks for joining us. We are here at React Summit 2025, joined by Lydia Halle. We'll get into some talks with regards to React Summit and we'll end off with a little bit of more ideas and randomized questions. So let's get into it. Let's talk about React Compiler. You just had your talk. I'm wondering why does React Compiler exist in the first place? We often have to like memoize stuff in React just because of how its rendering system works. And that's just how React is designed. But for a lot of developers, that's definitely a burden, having to use memo, use callback every time that there is either an expensive function or an object. So first you have to identify, okay, will this part rerun whenever the parent component re renders, or is this memoizable enough? And as I said in my talk, it's very easy if you don't have the right Linter plugins to accidentally forget to add stuff to your dependency array and a useMemo which then breaks the entire memoization chain. Or what I have sometimes had is that I add a value to the dependency array, but it's like an always changing value, so then you're breaking your entire memorization that you had for that component. So all in all, it's just pretty error prone and it just requires a lot of like, maintenance, especially as your code base grows. So React Compiler kind of just takes that away from developers. It's more shifting that responsibility to React itself. It's like, okay, we know that you often have to memoize stuff in your React components just due to the way that our rendering system works. And React Compiler automatically helps with memoizing the right values in your components. So developers don't have the burden of that anymore. And a nice thing with Compiler is that it can get really granular. So with UseMemo, of course, we could sometimes maybe memoize an expensive computation or with use callback and expensive function and so on. But as I also said in my talk, React Compiler is able to memoize JSX or really tiny variables that normally developers wouldn't really memoize with musmemo. Okay, so it's both easier with compiler because we don't have to think about anything. We can just write clean code. But then also in a lot of cases, it gets even better performance just because it's able to memoize more than what we normally would if we would use Memo. So I understand it's going to solve it kind of in an automatic way. Is there still room for like Using use callback or usememo, then from a developer side, yeah, you can still use it if it's still in your code base. React compiler would either automatically strip it out and then, you know, because we have a usememo or use callback and then the callback function, it would just strip out use callback and just use that callback function instead. Also, in a lot of cases you can just enable React compiler and if you don't want to memoize a specific component, you can use the usenomemo directive on top of that component. So in that case you're kind of opting out of just memorizing that component and keeping your own manual memorizations in anyways. But yeah, generally if you want to move over to Compiler, I would say keep all the useMemo use callbacks in there in case you do want to turn it off eventually so you don't have to undo all your previous undos. Yeah, because compiler will take care of that automatically. Interesting. I like the idea of not having this cognitive load of rendering cycles and then figuring out what to use callback or use Memo for. You just want to write code. Yeah. The only additional thing now is like I have to actively say, okay, if I don't want React React compiler to kick in, is that additional? I mean, you enable React compiler, so if you don't want it at all, then of course you don't have to enable it. But yeah, if you don't want it for certain components, then you can use the Use no memo directive and it'll skip that specific component from being memoized. But of course, also like, if you break any of the rules of reaction or like I said, more complex patterns and it's not sure how to optimize it, Compiler will always choose the safe side. It won't try to just memorize something just to memorize something, because if that goes wrong, that would really break your app. Like if you accidentally have a cached value that should be recalculated in every render so it always pick the safe path in that way. Yeah, I like that. How easy is it to set it up either through an existing code base or when starting something new? So first you might run NPX React Compiler health check. That will just tell you like, okay, is this code base compatible with Compiler or does it have any dependencies in here or any breaking the rules of React that it won't work? Then there's also the Islint plugin, and this is what most developers will use in their code base to Work with compiler because this will automatically tell you if what you're doing in the current code base might break. Compiler would optimize. It'll also, you know, tell you like, oh, maybe don't use this hook in that case and so on. But yeah, then, then it's just turning it on in your build pipeline. So yeah, in Expo could be in your app JSON, in Next js, it could be in your next config file. In Vite they also have because it's just a Babel plugin, so you essentially just add it like as a Babel plugin and then it just runs every time that you build your code, but also on hmr. So if you do want to update just in development, it will also run there. Mm. For me it's interesting how this is gonna move and kind of migrate because right now people have this cognitive load, they have to think about it. Yeah. And then when you use React Compiler you don't have to think about it all of a sudden. Will people still like use it, you think? Or will they use it more consciously or it's just gonna be out of the tool belt because you don't have to think about it. I mean I feel like eventually people won't have to use it anymore. But like it is definitely like backwards compatible. Cause of course you cannot like a lot of code base. Yeah, like so many code bases use memo and it's not like you can only use compiler if you don't take out all these UseMemo use calls. Yeah, no, eventually we'll hopefully end up with just really clean react code that is also really performant and we don't have to think about all this re rendering stuff. And especially on low end devices it will definitely make a big difference. Compiler because I feel like, you know, if you're running it on a really fast MacBook or really fast iPhone, having those couple extra milliseconds on the website is like whatever. But of course if you're running it on like a low end Android device, you'll definitely see a big, big like performance increase in how like in ux in user experience. So yeah, it's been a while since I've done front end development, but re rendering cycles as code bases grow were always a pain. Yeah, like a huge pain. Exactly. Especially as it grows in with like new members on your team and they have to really identify like okay, what is this? You know, just to be focused on UseMemo use copy specifically now like okay, but why do we need this dependency? And if you Change anything you need to add it to the dependency array. It's just. And of course there are linters for it and in VS code you can. Or in cursor you can see like oh yeah, I have to add it. But still it's just like it's like tooling around this problem that we had. Exactly, yeah. So again it's shifting kind of the responsibility from the developers to React itself. I like that a lot. Is this going to solve most then rerendering problems or what remains after you've incorporated React compiler? I mean I feel like eventually they might integrate it with other. It could be optimized for other kind of rendering engines as well. JavaScript engines. So in that case you can run React code really fast if you're running it on for example like Hermes, stuff like that on mobile devices. Also just having compiler in general, of course it makes sure that you're not breaking any other rules of React that might be kind of forgiven now, but compiler just won't work if you're using those. So in that sense it could also help you just to write better React code. Yeah, I feel like that's a trend in the industry. Like we come from frameworks and a lot of cognitive load and now we see that the simpler it is for developers to execute and kind of use code as a means to an end to achieve something, the better it is also for maintainability for easier for people to step in, specifically with regards to conventions. For sure. Yeah. If this is a trend that I think is going to hold strong. Yeah, right, yeah. But then also everything is going to be kind of solved because you don't see the rewrites. Right, that happens. No, it all happens. And you also get to keep the source maps from your original code. So when you're opening dev tools or anything like that, you won't see that it changed the code because the original source map, so the original kind of structure of your components is still there. Yeah, so that's super nice that you don't have to. I mean everything I presented today, you can just forget about it like it's. No one has to ever think about it. But just the fact that it happens. And also kind of the engineering that went like to build Compiler I find really impressive and a lot of respect to the people at Meta. Can you touch a little bit about that? Because I mean building this thing and then keeping in mind all the existing code that is there with regards to backwards compatibility, that is always a challenge in and of its own for sure. Well, what do you want me to touch on specific people? Mainly how they created this thing? Because it's a lot of logic that goes into compilers. It's trade offs with regards to performance. Yeah, I mean I'm of course not entirely sure how to like how they started and where it is now. But compiler itself, I mean if you know, I guess the basics of compiler theory, it's just like, I mean, I'm not even sure if it's like if compiler is the right word. I know there's a whole discussion around it because it's not like we're compiling it to a lower end language, which is normally what compiler is. It's almost like we're transpiling it back to JavaScript. But yeah, no, the whole process, I mean the fact that they're using first the high intermediate or high level intermediate representation, that's pretty obvious. But then they're also using like stuff like ssa, so the single static assignment to just make sure that it really understands the data flow within a single component. And that's pretty complex. Like it shows that, you know, the people at compiler really thought about getting the best performance out of it as well. Yeah, I'm not entirely sure how to answer that question. The question is like a vague one. But yeah, I get that with regards to kind of working with React, this was always a pain point. Now that it's kind of solved already. So is it production ready? Let's start with that first. No, it's a release candidate. Yeah. So as of April 2025. Yeah, it was beta before that. So people can use it in their apps and see if it works. I mean Meta has been using it internally and a lot of their products and of course I'm not entirely sure if they're using the exact same versions of, if they're using kind of internal modifications of that to make that work and that Instagram and stuff like that so people can like incrementally move over and see if it does anything for the apps because it's so easy to just opt out by just not enabling it anymore. So it's easy, but so far, as far as I know, no other bigger companies have really turned it on to really see, to get good metrics on how much it improved. I know for Instagram I believe they got like a 30% improvement just turning on compiling. That's incredible. That's really good. Yeah. Yeah, I'm not sure for any other numbers so far till it's like out of stable, I guess. Yeah. If it really fixes this pain point of RE rendering, which I think is bringing this huge cognitive load. What do you think is still missing then? What other frameworks offer with regards to developer experience or people creating code within React? Oh, do you still see any pain points? It's a good question, I feel like, because I don't even think you have to really use State anymore because if it can just track reactivity within the variable, then it would just do that automatically for you. And that's of course also why a lot of people liked stuff like svelte and stuff. You could just kind of declare a variable. It was closer to HTML at that point. Other than that, I kind of only see wins for React, which I know sounds really one sided, but more people are moving over to React, the community is growing, the tooling is getting easier and better, the code base is getting easier to maintain. I don't really see any big downsides to React anymore at this point because that was definitely having all these hooks and then having to memorize that was for me the biggest pain point. And seeing how other frameworks solved it was definitely like, man, that looks nice. So, yeah, hopefully once compiler is stable, we'll also get to that point. It's funny that you mention that because when a lot of new frameworks were introduced, it's like, okay, here's how you would do it in React and look how clean it is in this kind of newer framework. Yeah, and that's like, look at us, we can also do it. Yeah, yeah. I mean, I feel like a lot of frameworks, they come and go, some stick a little bit, but React still stands tall, I feel like. Yeah. And people have questioned it a lot and it's only growing. So no, I'm confident that React will only get better. Yeah, yeah, nice. So would you recommend then for people to, whenever they start a new project to pick up React comparing to other frameworks or is there still a use case for the other frameworks? There's always use cases, but I feel like having React and then also it works also on React Native, you kind of have the entire spectrum. You have web, you've got Native, you've got other integrated devices like the Meta quest or all these things. To me, that's just the biggest win in React and also just the community and the information around React, the responses that Cursor and chatgpt give are often by default React as well. So like a lot of LLMs are trained on React as well. So it's just the easiest one. Of course, now with hooks, there was Like, I guess a steeper learning curve. A lot of time in React. I don't really, because I learned it back in 2015. So it's difficult for me to know how people would approach it nowadays when they don't have any experience. But yeah, like when you don't have to think about hooks anymore or like memorization, it makes it easier for, for everyone also for beginners to get into it. So that's very exciting. Yeah, I think that's important, especially for languages that have this level of maturity. To still be accessible for new learners is incredibly important. Exactly. And that's. That was definitely difficult with hooks. I felt like, awesome. I have a few random questions on the table. They're not about React, they're not about React compiler. They're more so about you and your opinion. I'm going to let you draw one. All right. Do you want to point to one and then I'll pick it and I'll read it. This one going with my intuition here, but it's never right. All right, what's one tech trend you wish would just go away? Tech trend. AI generated code. Vibe coding. Vibe coding specifically. I don't, I feel like a lot of the time, you know, the code still that it produces, it's just not great. I love using these tools like cursor and stuff for it to reverse engineer code bases and to, you know, when I'm starting something new, I can just get a really quick overview of everything that's happening in the code and where it happens. But still, the code that AI generates often for me is it's just not good. Like it's really good to prototype, but really production ready code, it's just not there yet. I'm sure it will be there pretty soon, faster than we all expect. But at the moment it isn't. And you know, I'm happy that people can get off the ground, I guess, with their ideas using Vibe coding and stuff like that. But I have yet to see a product that actually lasts longer than a couple of months that was completely built with just AI. Also, I feel like it just gets, of course, the normal ones difficult to maintain because you don't really know what your code is doing. But personally, I feel like it's easier for me to get burnt out on a project when it's entirely made with just AI because I feel less of a connection to it. And the moment I feel like I'm not really in control of what I'm working with or that I don't really understand what it's doing. I'm also just less interested in it. And that's just, of course, my very personal opinion. Yeah, people are of course, very different, but I feel like people should still see not necessarily pride but also necessity in writing your own code. Because a lot of time, I guess some people, it might make you feel a bit bad when they're like, oh, I could have just vibe coded this for something much faster. Get all this mrr, whatever people are tweeting nowadays, like, oh man, I could have been a millionaire by now. Like, well, not, not really. Like, yeah, I mean, maybe if you had like a good idea and you actually also, you know, change the generated code yourself then for sure. But you cannot just rely at the moment on the entire output of AI generated code. So I mean, I'm not wishing it would go away, I'm just saying it's not quite there yet. So people shouldn't think that it's, you know, the AI is going to take over software engineering just yet, but this will age terribly. I'm sure that like I will look at this in five years and pour in like box industry because, like it took my job. I gu. Yeah. Do you think it's going to make for better engineers or for worse engineers? Because I feel like indeed people go on this autopilot mode. Yeah, just code that is generated and you just accept or you have to consistently read and you don't think anymore. I think it depends on your initial motivation. Like if you were interested in computer science and really building the project, it will definitely help you make like, help you become a better programmer. Because that's when you already kind of have this, you want to learn. And then I can of course do that so much faster and it's such a more kind of gratifying way where you don't have to just go to stack overflow with like 15 year old, you know, answers that are no longer applicable, stuff like that. But if your goal is more to like, okay, how can I make money quick? And then, you know, yeah, how would I code it then? Yeah, of course, like, even if you had some coding experience, I still feel like it would definitely make you worse because you're not really thinking about the patterns. You might not stay as up to date with the, you know, new features that are in a framework, which is fine if you're just relying on AI, but still like, yeah, you're working with code that's not yours. I find that too risky, I guess. But I feel like you could say that in general about just AI now People are kind of just like moving their thinking over to Jet GPT or everything else. I feel like in a couple of years from now, critical thinking will be the most valuable asset if people are still willing to put the effort into just thinking critically, their own thoughts, not just kind of pushing it to AI. So, yeah, it'll be interesting to see what the junior developer will look like in five years from now. I have no idea if they will still exist because I feel like a lot of junior tasks are pretty much just AI tasks. That's pretty doable, but people still have to learn. So, yeah, it's going to be interesting. Yeah, the learning curve is going to be different. Right. Because if a lot of the easier tasks that help you get up and running are solved, then there's nothing left. Yeah. And like, yeah, I'm not sure how companies would hire those people because it's like you're not really needed, but you still need the work experience. So that's another issue. I guess that it's going to be interesting, see how that turns out. Yeah. And we also talked about, I mean, mainly React Compiler is solving this kind of cognitive load, but with AI, you still have the same cognitive load because it spits out code that is for humans. Right. It's not machine code, it's what we've created to kind of make better abstractions for ourselves, to be able to create code so the cognitive load doesn't decrease. I feel like you just have to read more and trying to understand more or indeed just blindly accept whatever's there. Yeah, I feel like that's what most people do anyway. There's like, shirt. I feel like. Yeah, very lazy. And then also. Yeah, just that, like, more disconnected to the product that you're building because I don't know, I still. Yeah, I don't know. Like, I. I'm sometimes just almost proud of the code I write. I almost see it as like my little. Not like a little baby, but like just something, you know, my own creation. I like it and you can be proud of it. And I feel like you just don't have that or I don't not. I don't want to generalize, but I don't have that. With AI, I'm just like, you know, like, people expected this of me, but it's not like I can take any pride in it that makes sense. No, I do feel completely what you mean. Sometimes you. Or at least for me, an existing code basis. I develop this feature and I'm really happy with how it's. I don't know why with intricacies there are, but I'm really happy with what I created. Yeah, yeah, yeah. And I did that. It's not like I used something to generate something, and then it's my creativity. Exactly. Yeah. You can just see your own thought patterns on the screen. Cool. Thank you so much, Lydia, for joining us. Thank you so much. We'll see you on the next one.